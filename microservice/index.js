const ethers = require("ethers");
const abi = require('./abi.json');
require('dotenv').config();

const wssUrl = process.env.RPC_URL; // Update this to your local Anvil WebSocket URL

console.log(wssUrl); // For debugging purposes
const router = "0xE592427A0AEce92De3Edee1F18E0157C05861564"; //Uniswap v3 SwapRouter

const iface = new ethers.Interface(abi);

const recentCalls = {}; // To track recent calls to each contract
const activeCalls = new Set();

async function main() {
  const provider = new ethers.WebSocketProvider(wssUrl);
  provider.on('pending', async (tx) => {
    const txnData = await provider.getTransaction(tx);
    if (txnData) {
      // console.log("Pending transaction: ", txnData['hash']);
      let gas = txnData['gasPrice'];
      if (txnData.to == router && txnData['data'].includes("0x414bf389")) {
        console.log("hash: ", txnData['hash']);
        let decoded = iface.decodeFunctionData("exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))", txnData['data']);
        logTxn(decoded, gas);
        // Check for reentrancy attack
        if (isReentrancyAttack(txnData)) {
          console.log("Potential reentrancy attack detected in transaction: ", txnData['hash']);
        }
      }
    }
  });
}

function isReentrancyAttack(txnData) {
  const currentTime = Date.now();
  const contractAddress = txnData.to;

  // Initialize the recentCalls array for the contract address if it doesn't exist
  if (!recentCalls[contractAddress]) {
    recentCalls[contractAddress] = [];
  }

  // Remove calls older than 1 second
  recentCalls[contractAddress] = recentCalls[contractAddress].filter(callTime => currentTime - callTime < 1000);

  // Add the current call
  recentCalls[contractAddress].push(currentTime);

  // Check if the current transaction is already in the activeCalls set
  const isAlreadyActive = activeCalls.has(contractAddress);

  // If the current call is already active, it's a potential reentrancy attack
  if (isAlreadyActive) {
    return true;
  }

  // Mark the current call as active
  activeCalls.add(contractAddress);

  // If there are more than 1 call within 1 second, it's a potential reentrancy attack
  if (recentCalls[contractAddress].length > 1) {
    // Clean up the active call after processing
    activeCalls.delete(contractAddress);
    return true;
  }

  // Clean up the active call after processing
  activeCalls.delete(contractAddress);
  return false;
}

async function logTxn(data, gas) {
  console.log("tokenIn: ", data['params']['tokenIn']);
  console.log("tokenOut: ", data['params']['tokenOut']);
  console.log("amount: ", data['params']['amountOutMinimum'].toString());
  console.log("gasPrice: ", gas.toString());
  console.log("-------------");
}

main();