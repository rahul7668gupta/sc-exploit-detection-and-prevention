package service

import (
	"context"
	"log"
	"strings"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/rahul7668gupta/sc-exploit/pkg/model"
)

func (cp *ContractPauser) ProcessPendingTransaction(txHash common.Hash, metrics *model.PerformanceMetrics) {
	startTime := time.Now()
	tx, isPending, err := cp.client.TransactionByHash(context.Background(), txHash)
	if err != nil {
		// if a txnHash is not found, it means we need to retry fetching the transaction, send the txnHash back to the channel
		if strings.Contains(err.Error(), "not found") {
			metrics.ErrorNotFoundTxCount++
			log.Printf("Transaction %s not found, retrying", txHash.Hex())
			// this is being done since we are not able to get any transaction details for pending transactions
			// cp.pendingTxs <- txHash
		} else {
			metrics.ErrorTxCount++
			log.Printf("Error fetching transaction %s: %v", txHash.Hex(), err)
		}
		return
	}

	if tx.To() != nil && !strings.EqualFold(tx.To().Hex(), cp.contractAddr.Hex()) {
		// log.Printf("Transaction %s is not related to the contract %s", txHash.Hex(), cp.contractAddr.Hex())
		return
	}

	log.Printf("Processing transaction data for hash %s, data: %s", tx.Hash().Hex(), tx.Data())

	if !isPending {
		return
	}

	metrics.ProcessedTxCount++

	if cp.IsSuspiciousTransaction(tx) {
		log.Printf("Suspicious transaction detected: %s", txHash.Hex())
		metrics.SuspiciousTxCount++
		cp.PauseContract(txHash)
	}

	metrics.AverageTxProcessTime = (metrics.AverageTxProcessTime*float64(metrics.ProcessedTxCount-1) + time.Since(startTime).Seconds()) / float64(metrics.ProcessedTxCount)
}
