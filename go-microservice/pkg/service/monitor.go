package service

import (
	"context"
	"log"
	"math/big"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/rahul7668gupta/sc-exploit/pkg/model"
)

type TxPoolContent struct {
	Pending map[string]map[string]TxPoolTransaction `json:"pending"`
}

type TxPoolTransaction struct {
	BlockHash        string `json:"blockHash"`
	BlockNumber      string `json:"blockNumber"`
	From             string `json:"from"`
	Gas              string `json:"gas"`
	GasPrice         string `json:"gasPrice"`
	Hash             string `json:"hash"`
	Input            string `json:"input"`
	Nonce            string `json:"nonce"`
	To               string `json:"to"`
	TransactionIndex string `json:"transactionIndex"`
	Value            string `json:"value"`
}

type TransactionDetails struct {
	Hash        common.Hash     `json:"hash"`
	From        common.Address  `json:"from"`
	To          *common.Address `json:"to"`
	Input       string          `json:"input"`
	Value       *big.Int        `json:"value"`
	GasLimit    uint64          `json:"gas"`
	GasPrice    *big.Int        `json:"gasPrice"`
	Nonce       uint64          `json:"nonce"`
	BlockHash   *common.Hash    `json:"blockHash"`
	BlockNumber *big.Int        `json:"blockNumber"`
}

type FeeHistoryResponse struct {
	BaseFeePerGas []string `json:"baseFeePerGas"`
}

func (cp *ContractPauser) GetBaseFee() (*big.Int, error) {
	var feeHistory FeeHistoryResponse
	err := cp.client.Client().CallContext(context.Background(), &feeHistory, "eth_feeHistory", 1, "latest", []float64{})
	if err != nil {
		return nil, err
	}

	if len(feeHistory.BaseFeePerGas) > 0 {
		baseFee, _ := new(big.Int).SetString(feeHistory.BaseFeePerGas[0][2:], 16)
		return baseFee, nil
	}

	return big.NewInt(0), nil
}

func (cp *ContractPauser) MonitorPendingTransactions() {
	go func() {
		var metrics model.PerformanceMetrics
		metricsTicker := time.NewTicker(5 * time.Second)
		defer metricsTicker.Stop()
		for {
			select {
			// case err := <-sub.Err():
			// 	log.Fatal(err)
			case pendingTxn := <-cp.pendingTxnDetails:
				go cp.ProcessPendingTransactionWithDetail(pendingTxn, &metrics)
			// case txHash := <-cp.pendingTxs:
			// go cp.ProcessPendingTransaction(txHash, &metrics)
			case <-metricsTicker.C:
				cp.storePerformanceMetrics(metrics)
				metrics = model.PerformanceMetrics{
					ProcessedTxCount: 0,
				}
			}
		}
	}()

	var result TxPoolContent
	err := cp.client.Client().CallContext(context.Background(), &result, "txpool_content")
	if err != nil {
		log.Fatalf("Failed to get pending transactions: %v", err)
	}

	// baseGasFee, err := cp.GetBaseFee()
	// if err != nil {
	// 	log.Fatalf("Failed to get base fee: %v", err)
	// }

	for _, txs := range result.Pending {
		for _, tx := range txs {
			gas, _ := new(big.Int).SetString(tx.Gas[2:], 16)
			gasPrice, _ := new(big.Int).SetString(tx.GasPrice[2:], 16)
			value, _ := new(big.Int).SetString(tx.Value[2:], 16)
			nonce, _ := new(big.Int).SetString(tx.Nonce[2:], 16)

			var to *common.Address
			if tx.To != "" {
				toAddr := common.HexToAddress(tx.To)
				to = &toAddr
			}

			if to == nil {
				// log.Printf("Transaction %s has no recipient", tx.Hash)
				continue
				// } else if to.Hex() != cp.contractAddr.Hex() {
				// log.Printf("Transaction %s is not related to the contract %s", tx.Hash, cp.contractAddr.Hex())
				// continue
			}

			if tx.Input == "0x" {
				// log.Printf("Transaction %s has no input data", tx.Hash)
				continue
			}

			// if baseGasFee.Cmp(gasPrice) > 0 {
			// log.Printf("Transaction %s has gas price lower than the base fee", tx.Hash)
			// continue
			// }

			txDetails := TransactionDetails{
				Hash:     common.HexToHash(tx.Hash),
				From:     common.HexToAddress(tx.From),
				To:       to,
				Input:    tx.Input,
				Value:    value,
				GasLimit: gas.Uint64(),
				GasPrice: gasPrice,
				Nonce:    nonce.Uint64(),
			}
			// send txn to the channel
			cp.pendingTxnDetails <- txDetails
			log.Printf("Pending transaction: %+v", txDetails)
		}
	}
}

func (cp *ContractPauser) IsSuspiciousTransaction(tx *types.Transaction) bool {
	// Implement your suspicious transaction detection logic here
	if tx.To() != nil && *tx.To() == cp.contractAddr {
		if tx.Value().Cmp(big.NewInt(1e18)) > 0 { // e.g., if value > 1 ETH
			return true
		}
	}
	return false
}
