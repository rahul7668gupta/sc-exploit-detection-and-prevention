// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/console.sol";
import "forge-std/Test.sol";
import "../src/VulnerableContract.sol";
import "../src/FixedContract.sol";
import "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";
import "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";
import "../src/AttackContract.sol";

contract VulnerableContractTest is Test {
    address public wrappedProxy;
    VulnerableContract public vulnerableContract;
    FixedContract public fixedContract;
    TransparentUpgradeableProxy public proxy;
    ProxyAdmin public proxyAdmin;

    address payable public attacker;

    function setUp() public {
        // Deploy the ProxyAdmin
        proxyAdmin = new ProxyAdmin(msg.sender);

        // Deploy the initial implementation (VulnerableContract)
        vulnerableContract = new VulnerableContract();
        vulnerableContract.initialize();

        // Deploy the fixed implementation (FixedContract)
        fixedContract = new FixedContract();
        fixedContract.initialize();

        // Deploy the proxy, pointing to Fix1Contract
        bytes memory initData = abi.encodeWithSelector(VulnerableContract.initialize.selector);
        proxy = new TransparentUpgradeableProxy(address(vulnerableContract), address(proxyAdmin), initData);

        // Wrap the proxy for easier interaction
        wrappedProxy = address(proxy);
        attacker = payable(address(0x123));
    }

    function testUpgrade() public {
        // Ensure the correct owner is calling the upgradeAndCall function

        vm.prank(msg.sender);
        proxyAdmin.upgradeAndCall(ITransparentUpgradeableProxy(address(proxy)), address(fixedContract), "");
    }

    function testReentrancyAttack() public {
        AttackContract attackContract = new AttackContract(TransparentUpgradeableProxy(proxy));

        vm.deal(address(attackContract), 10 ether);
        vm.startPrank(address(attackContract));
        // Attacker deposits some funds
        attackContract.deposit{value: 9 ether}();
        vm.stopPrank();

        // Simulate a reentrancy attack
        attackContract.attack(1 ether);

        // Assert that the attacker has drained the funds
        assertEq(address(proxy).balance, 0);
        // Assert that the attacker has received the all funds
        assertEq(address(attackContract).balance, 10 ether);
    }

    function testFixedContractNonReentrancy() public {
        vm.prank(msg.sender);
        proxyAdmin.upgradeAndCall(ITransparentUpgradeableProxy(address(proxy)), address(fixedContract), "");

        // Deposit funds into the upgraded contract
        (bool success,) = address(proxy).call{value: 1 ether}(abi.encodeWithSignature("deposit()"));
        require(success, "Deposit failed");

        // Attempt to attack the upgraded contract
        AttackContract attackContract = new AttackContract(TransparentUpgradeableProxy(proxy));
        vm.expectRevert("Withdraw failed");
        attackContract.attack(1 ether);

        // Assert that the contract balance is intact
        assertEq(address(proxy).balance, 1 ether);
    }

    receive() external payable {}
}
