package service

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/rahul7668gupta/sc-exploit/pkg/model"
)

func (cp *ContractPauser) ProcessPendingTransaction(txHash common.Hash, metrics *model.PerformanceMetrics) {
	startTime := time.Now()
	tx, isPending, err := cp.client.TransactionByHash(context.Background(), txHash)
	if err != nil {
		// if a txnHash is not found, it means we need to retry fetching the transaction, send the txnHash back to the channel
		if strings.Contains(err.Error(), "not found") {
			metrics.ErrorNotFoundTxCount++
			// log.Printf("Transaction %s not found, retrying", txHash.Hex())
			// this is being done since we are not able to get any transaction details for pending transactions
			// cp.pendingTxs <- txHash
		} else {
			metrics.ErrorTxCount++
			log.Printf("Error fetching transaction %s: %v", txHash.Hex(), err)
		}
		return
	}

	if tx.To() != nil && !strings.EqualFold(tx.To().Hex(), cp.contractAddr.Hex()) {
		// log.Printf("Transaction %s is not related to the contract %s", txHash.Hex(), cp.contractAddr.Hex())
		return
	}

	log.Println("Processing transaction data for hash", tx.Hash().Hex(), tx.ChainId(), tx.Gas())

	if !isPending {
		return
	}

	metrics.ProcessedTxCount++

	if cp.IsSuspiciousTransaction(tx) {
		log.Printf("Suspicious transaction detected: %s", txHash.Hex())
		metrics.SuspiciousTxCount++
		cp.PauseContract(txHash)
	}

	metrics.AverageTxProcessTime = (metrics.AverageTxProcessTime*float64(metrics.ProcessedTxCount-1) + time.Since(startTime).Seconds()) / float64(metrics.ProcessedTxCount)
}

func (cp *ContractPauser) SimulateTransaction(txDetails TransactionDetails) error {
	url := "http://localhost:3000/simulate-transaction"

	jsonData, err := json.Marshal(txDetails)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to send transaction details, status code: %d", resp.StatusCode)
	}
	log.Printf("Transaction simulated successfully: %+v", resp.Body)

	return nil
}

func (cp *ContractPauser) ProcessPendingTransactionWithDetail(txn TransactionDetails, metrics *model.PerformanceMetrics) {
	// log.Printf("Processing transaction data for obj %+v", txn)
	cp.SimulateTransaction(txn)

	// startTime := time.Now()
	// tx, isPending, err := cp.client.TransactionByHash(context.Background(), txHash)
	// if err != nil {
	// 	// if a txnHash is not found, it means we need to retry fetching the transaction, send the txnHash back to the channel
	// 	if strings.Contains(err.Error(), "not found") {
	// 		metrics.ErrorNotFoundTxCount++
	// 		// log.Printf("Transaction %s not found, retrying", txHash.Hex())
	// 		// this is being done since we are not able to get any transaction details for pending transactions
	// 		// cp.pendingTxs <- txHash
	// 	} else {
	// 		metrics.ErrorTxCount++
	// 		log.Printf("Error fetching transaction %s: %v", txHash.Hex(), err)
	// 	}
	// 	return
	// }

	// if tx.To() != nil && !strings.EqualFold(tx.To().Hex(), cp.contractAddr.Hex()) {
	// 	// log.Printf("Transaction %s is not related to the contract %s", txHash.Hex(), cp.contractAddr.Hex())
	// 	return
	// }

	// log.Println("Processing transaction data for hash", tx.Hash().Hex(), tx.ChainId(), tx.Gas())

	// if !isPending {
	// 	return
	// }

	// metrics.ProcessedTxCount++

	// if cp.IsSuspiciousTransaction(tx) {
	// 	log.Printf("Suspicious transaction detected: %s", txHash.Hex())
	// 	metrics.SuspiciousTxCount++
	// 	cp.PauseContract(txHash)
	// }

	// metrics.AverageTxProcessTime = (metrics.AverageTxProcessTime*float64(metrics.ProcessedTxCount-1) + time.Since(startTime).Seconds()) / float64(metrics.ProcessedTxCount)
}
