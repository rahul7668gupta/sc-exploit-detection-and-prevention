package service

import (
	"context"
	"fmt"
	"log"
	"math/big"
	"strings"
	"time"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/rahul7668gupta/sc-exploit/pkg/constants"
)

func (cp *ContractPauser) PauseContract(triggeringTxHash common.Hash) (string, error) {

	ctx, ctxCancel := context.WithTimeout(context.Background(), 20*time.Second) // buffer including block time
	defer ctxCancel()
	gasPrice, err := cp.GetDynamicGasPrice()
	if err != nil {
		log.Printf("Failed to get dynamic gas price: %v", err)
		return "", err
	}

	chainID, err := cp.client.ChainID(ctx)
	if err != nil {
		log.Printf("Failed to get chain ID: %v", err)
		return "", err
	}

	privateKey, err := crypto.HexToECDSA(cp.privateKey)
	if err != nil {
		log.Printf("Failed to convert private key: %v", err)
		return "", err
	}

	auth, err := bind.NewKeyedTransactorWithChainID(privateKey, chainID)
	if err != nil {
		log.Printf("Failed to create authorized transactor: %v", err)
		return "", err
	}

	auth.GasPrice = gasPrice
	gasLimit, err := cp.EstimateGas(&auth.From, &cp.contractAddrVulnerableProxy, gasPrice, nil)
	if err != nil {
		log.Printf("Failed to estimate gas: %v", err)
		return "", err
	}
	auth.GasLimit = gasLimit + 100000 // for buffer

	tx, err := cp.CreatePauseTransaction(auth)
	if err != nil {
		log.Printf("Failed to pause contract: %v", err)
		cp.storePauseEvent(triggeringTxHash.Hex(), "", false)
		return "", err
	}

	// Sign the transaction
	signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), privateKey)
	if err != nil {
		log.Printf("Failed to sign transaction: %v", err)
		return "", err
	}

	// Send the transaction
	err = cp.client.SendTransaction(ctx, signedTx)
	if err != nil {
		log.Printf("Failed to send transaction: %v", err)
		return "", err
	}

	log.Printf("Pause transaction sent for hash: %s", signedTx.Hash().Hex())

	receipt, err := bind.WaitMined(ctx, cp.client, signedTx)
	if err != nil {
		log.Printf("Failed to get transaction receipt: %v", err)
		cp.storePauseEvent(triggeringTxHash.Hex(), signedTx.Hash().Hex(), false)
		return "", err
	}

	log.Printf("Contract paused. Pause transaction mined in block %d", receipt.BlockNumber.Uint64())
	cp.storePauseEvent(triggeringTxHash.Hex(), signedTx.Hash().Hex(), true)
	return signedTx.Hash().Hex(), nil
}

func (cp *ContractPauser) CreatePauseTransaction(auth *bind.TransactOpts) (*types.Transaction, error) {
	// Parse the ABI
	parsedABI, err := abi.JSON(strings.NewReader(constants.PauseABI))
	if err != nil {
		return nil, fmt.Errorf("failed to parse ABI: %v", err)
	}

	// Encode the function call
	data, err := parsedABI.Pack("pause")
	if err != nil {
		return nil, fmt.Errorf("failed to encode function call: %v", err)
	}

	// Get the nonce for the auth account
	nonce, err := cp.client.PendingNonceAt(context.Background(), auth.From)
	if err != nil {
		return nil, fmt.Errorf("failed to get nonce: %v", err)
	}
	auth.Nonce = big.NewInt(int64(nonce))

	// Create a new transaction
	tx := types.NewTransaction(
		auth.Nonce.Uint64(),
		cp.contractAddrVulnerableProxy,
		big.NewInt(0),
		auth.GasLimit,
		auth.GasPrice,
		data,
	)

	return tx, nil
}

func (cp *ContractPauser) GetDynamicGasPrice() (*big.Int, error) {
	suggestedGasPrice, err := cp.client.SuggestGasPrice(context.Background())
	if err != nil {
		return nil, err
	}

	premium := new(big.Int).Div(suggestedGasPrice, big.NewInt(5))
	return new(big.Int).Add(suggestedGasPrice, premium), nil
}

func (cp *ContractPauser) EstimateGas(from *common.Address, to *common.Address, gasPrice *big.Int, data []byte) (uint64, error) {
	msg := ethereum.CallMsg{
		From:     *from,
		To:       to,
		GasPrice: gasPrice,
		Data:     data,
	}

	return cp.client.EstimateGas(context.Background(), msg)
}
