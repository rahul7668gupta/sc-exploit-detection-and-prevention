import os
import re
import json
from web3 import Web3
from eth_utils import keccak, to_hex

# Load environment variables
from dotenv import load_dotenv

load_dotenv()

rpc_url = os.getenv("RPC_URL")  # Update this to your local Anvil WebSocket URL

# Replace with your Ethereum node URL (e.g., Infura endpoint)
# provider = Web3(Web3.HTTPProvider(rpc_url))

provider = Web3(Web3.WebsocketProvider(rpc_url))

# Heuristics and patterns for reentrancy detection
REENTRANCY_PATTERNS = [
    re.compile(r"call\.value\("),
    re.compile(r"\.transfer\("),
    re.compile(r"\.send\("),
    re.compile(r"delegatecall"),
]

VULNERABLE_FUNCTIONS = [
    "withdraw",
    "transfer",
    "send",
    "call",
]


def detect_reentrancy(tx_hash):
    try:
        tx = provider.eth.get_transaction(tx_hash)
        receipt = provider.eth.get_transaction_receipt(tx_hash)

        if not tx or not receipt:
            raise ValueError("Transaction not found")

        score = 0
        reasons = []

        # Check input data for suspicious patterns
        input_data = tx.input
        input_data_str = input_data.hex()
        for pattern in REENTRANCY_PATTERNS:
            if pattern.search(input_data_str):
                score += 2
                reasons.append(f"Suspicious pattern found: {pattern.pattern}")

        # Check for multiple calls to the same contract
        unique_addresses = set(log["address"] for log in receipt["logs"])
        if len(unique_addresses) < len(receipt["logs"]):
            score += 3
            reasons.append("Multiple calls to the same contract detected")

        # Check function signature
        function_signature = input_data[:10]  # First 4 bytes of the input data
        if function_signature != "0x":
            for func in VULNERABLE_FUNCTIONS:
                hash = to_hex(keccak(text=f"{func}()"))[:10]
                if function_signature == hash:
                    score += 2
                    reasons.append(f"Call to potentially vulnerable function: {func}")

        # Check gas usage (high gas usage might indicate complex operations)
        if receipt["gasUsed"] > 500000:
            score += 1
            reasons.append("High gas usage detected")

        # Analyze value transfer
        if tx["value"] > 0:
            score += 1
            reasons.append("Value transfer detected")

        # Check contract code for calls
        contract_code = provider.eth.get_code(tx["to"], tx["blockNumber"]).hex()

        if check_for_call_and_send(contract_code):
            score += 2
            reasons.append("Contract code contains call or send")

        # Check event logs for reentrancy patterns
        if check_event_logs(receipt["logs"]):
            score += 2
            reasons.append("Event logs indicate potential reentrancy")

        # Final assessment
        is_reentrancy = score >= 5

        return {
            "is_reentrancy": is_reentrancy,
            "score": score,
            "reasons": reasons,
            "tx_hash": tx["hash"].hex(),
            "from": tx["from"],
            "to": tx["to"],
        }
    except Exception as error:
        print("Error analyzing transaction:", error)
        raise error


def check_event_logs(logs):
    # Check event logs for patterns that might indicate reentrancy
    reentrancy_indicators = [
        "f1",  # CALL
        "f2",  # CALLCODE
        "f4",  # DELEGATECALL
        "fa",  # STATICCALL
        # Add more indicators if needed
    ]
    count = 0
    for log in logs:
        topics = log["topics"]
        for topic in topics:
            topic_hex = topic.hex()[2:]  # Convert to hex string and remove '0x' prefix
            if any(indicator in topic_hex for indicator in reentrancy_indicators):
                count += 1
    return count > 1  # to be configured


def check_for_call_and_send(contract_code):
    # Convert hex code to bytes
    code_bytes = bytes.fromhex(contract_code[2:])

    # Disassemble the bytecode
    disassembled_code = disassemble_bytecode(code_bytes)

    # Check for CALL and CALLCODE opcodes
    contains_call_or_send = any(
        instruction in ["CALL", "CALLCODE"] for instruction in disassembled_code
    )

    return contains_call_or_send


def disassemble_bytecode(bytecode):
    # Simple disassembler to identify opcodes
    opcodes = {
        0xF1: "CALL",
        0xF2: "CALLCODE",
        # Add more opcodes if needed
    }
    disassembled = []
    for byte in bytecode:
        if byte in opcodes:
            disassembled.append(opcodes[byte])
    return disassembled


def listen_to_pending_transactions(contract_address, abi_file):
    with open(abi_file, "r") as file:
        contract_abi = json.load(file)

    contract = provider.eth.contract(address=contract_address, abi=contract_abi)

    def handle_transaction(tx_hash):
        try:
            result = detect_reentrancy(tx_hash)
            if result["is_reentrancy"]:
                print(f"Reentrancy detected in transaction {tx_hash.hex()}: {result}")
            else:
                print(f"No reentrancy detected in transaction {tx_hash.hex()}")
        except Exception as error:
            print(f"Error processing transaction {tx_hash.hex()}: {error}")

    pending_filter = provider.eth.filter("pending")

    while True:
        for tx_hash in pending_filter.get_new_entries():
            try:
                tx = provider.eth.get_transaction(tx_hash)
                if tx["to"] and tx["to"].lower() == contract_address.lower():
                    handle_transaction(tx_hash.hex())
            except Exception as error:
                print(f"Error fetching transaction {tx_hash.hex()}: {error}")


# Usage example
def main():
    # # Replace with the transaction hash you want to analyze
    # tx_hash = "0xa6f63fcb6bec8818864d96a5b1bb19e8bd85ee37b2cc916412e720988440b2aa"
    # try:
    #     result = detect_reentrancy(tx_hash)
    #     print("Reentrancy Analysis Result:", result)
    # except Exception as error:
    #     print("Analysis failed:", error)
    contract_address = Web3.to_checksum_address(
        "0xE592427A0AEce92De3Edee1F18E0157C05861564"
    )  # Uniswap v3 SwapRouter'  # Replace with your contract address
    abi_file = "microservice/abi.json"  # Path to your ABI file
    listen_to_pending_transactions(contract_address, abi_file)


if __name__ == "__main__":
    main()
