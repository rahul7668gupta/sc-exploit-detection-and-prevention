package service

import (
	"context"
	"encoding/json"
	"log"
	"math/big"
	"strings"
	"sync"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/rahul7668gupta/sc-exploit/pkg/dto"
	"github.com/rahul7668gupta/sc-exploit/pkg/model"
)

type TxPoolContent struct {
	Pending map[string]map[string]TxPoolTransaction `json:"pending"`
}

type TxPoolTransaction struct {
	BlockHash        string `json:"blockHash"`
	BlockNumber      string `json:"blockNumber"`
	From             string `json:"from"`
	Gas              string `json:"gas"`
	GasPrice         string `json:"gasPrice"`
	Hash             string `json:"hash"`
	Input            string `json:"input"`
	Nonce            string `json:"nonce"`
	To               string `json:"to"`
	TransactionIndex string `json:"transactionIndex"`
	Value            string `json:"value"`
}

type TransactionDetails struct {
	Hash        common.Hash     `json:"hash"`
	From        common.Address  `json:"from"`
	To          *common.Address `json:"to"`
	Input       string          `json:"input"`
	Value       *big.Int        `json:"value"`
	GasLimit    uint64          `json:"gas"`
	GasPrice    *big.Int        `json:"gasPrice"`
	Nonce       uint64          `json:"nonce"`
	BlockHash   *common.Hash    `json:"blockHash"`
	BlockNumber *big.Int        `json:"blockNumber"`
}

type FeeHistoryResponse struct {
	BaseFeePerGas []string `json:"baseFeePerGas"`
}

func (cp *ContractPauser) GetBaseFee() (*big.Int, error) {
	var feeHistory FeeHistoryResponse
	err := cp.client.Client().CallContext(context.Background(), &feeHistory, "eth_feeHistory", 1, "latest", []float64{})
	if err != nil {
		return nil, err
	}

	if len(feeHistory.BaseFeePerGas) > 0 {
		baseFee, _ := new(big.Int).SetString(feeHistory.BaseFeePerGas[0][2:], 16)
		return baseFee, nil
	}

	return big.NewInt(0), nil
}

func (cp *ContractPauser) MonitorPendingTransactions() {

	var wg sync.WaitGroup

	wg.Add(1)
	// process pending transactions with details
	go func() {
		var metrics model.PerformanceMetrics
		metricsTicker := time.NewTicker(5 * time.Second)
		defer metricsTicker.Stop()
		// count := 0
		// process pending transactions
		for {
			select {
			case pendingTxn := <-cp.pendingTxnDetails:
				if pendingTxn.To != nil && !strings.EqualFold(pendingTxn.To.Hex(), cp.contractAddr.Hex()) {
					// log.Printf("Transaction %s is not related to the contract %s", pendingTxn.Hash.Hex(), cp.contractAddr.Hex())
					continue
				}
				// if count > 0 {
				// 	continue
				// } else {
				cp.ProcessPendingTransactionWithDetail(pendingTxn, &metrics)
				// count++
				// }
			case <-metricsTicker.C:
				cp.storePerformanceMetrics(metrics)
				metrics = model.PerformanceMetrics{
					ProcessedTxCount: 0,
				}
			}
		}
	}()

	wg.Add(1)
	// process pending transactions
	go func() {
		for result := range cp.pendingTxs {
			for _, txs := range result.Pending {
				for _, tx := range txs {
					gas, _ := new(big.Int).SetString(tx.Gas[2:], 16)
					gasPrice, _ := new(big.Int).SetString(tx.GasPrice[2:], 16)
					value, _ := new(big.Int).SetString(tx.Value[2:], 16)
					nonce, _ := new(big.Int).SetString(tx.Nonce[2:], 16)

					var to *common.Address
					if tx.To != "" {
						toAddr := common.HexToAddress(tx.To)
						to = &toAddr
					}

					if to == nil {
						// log.Printf("Transaction %s has no recipient", tx.Hash)
						continue
					} else if to.Hex() != cp.contractAddr.Hex() {
						// log.Printf("Transaction %s is not related to the contract %s", tx.Hash, cp.contractAddr.Hex())
						continue
					}

					txDetails := TransactionDetails{
						Hash:     common.HexToHash(tx.Hash),
						From:     common.HexToAddress(tx.From),
						To:       to,
						Input:    tx.Input,
						Value:    value,
						GasLimit: gas.Uint64(),
						GasPrice: gasPrice,
						Nonce:    nonce.Uint64(),
					}
					// send txn to the channel
					cp.pendingTxnDetails <- txDetails
				}
			}
		}
	}()

	wg.Add(1)
	// monitor pending txns from pool
	go func() {
		for {
			var result TxPoolContent
			err := cp.client.Client().CallContext(context.Background(), &result, "txpool_content")
			if err != nil {
				log.Fatalf("Failed to get pending transactions: %v", err)
			}
			cp.pendingTxs <- result
			time.Sleep(5 * time.Second)
		}
	}()

	wg.Wait()

	// baseGasFee, err := cp.GetBaseFee()
	// if err != nil {
	// 	log.Fatalf("Failed to get base fee: %v", err)
	// }
}

func (cp *ContractPauser) IsSuspiciousTransaction(result map[string]interface{}) (bool, error) {
	// Implement your suspicious transaction detection logic here

	var dtoResp dto.TenderlySimulateResponse

	resultBytes, err := json.Marshal(result)
	if err != nil {
		log.Printf("Failed to marshal result: %v", err)
		return false, err
	}

	err = json.Unmarshal(resultBytes, &dtoResp)
	if err != nil {
		log.Printf("Failed to unmarshal result: %v", err)
		return false, err
	}

	log.Println("Simulated transaction result:", dtoResp.Result.Logs)

	return false, nil
}
