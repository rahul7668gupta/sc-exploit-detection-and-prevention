import os
import time
import logging
from typing import Optional
from web3 import Web3
from web3.middleware import geth_poa_middleware
from eth_account import Account
from eth_account.signers.local import LocalAccount
from web3.contract import Contract
from web3.types import TxParams, Wei
import subprocess
import psycopg2

# Load environment variables
from dotenv import load_dotenv

load_dotenv()

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ContractPauser:
    def __init__(
        self,
        client_url: str,
        contract_addr: str,
        owner_addr: str,
        private_key: str,
        db_conn_string: str,
    ):
        self.w3 = Web3(Web3.HTTPProvider(client_url))
        self.w3.middleware_onion.inject(geth_poa_middleware, layer=0)
        self.contract_addr = Web3.to_checksum_address(contract_addr)
        self.owner_addr = Web3.to_checksum_address(owner_addr)
        self.private_key = private_key
        self.db_conn_string = db_conn_string
        self.account: LocalAccount = Account.from_key(private_key)

        # Load contract ABI and create contract instance
        with open("microservice/abi.json", "r") as abi_file:
            contract_abi = abi_file.read()
        self.contract = self.w3.eth.contract(
            address=self.contract_addr, abi=contract_abi
        )

    def get_dynamic_gas_price(self) -> int:
        return self.w3.eth.gas_price

    def send_pause_transaction(self) -> Optional[dict]:
        nonce = self.w3.eth.get_transaction_count(self.account.address)
        gas_price = self.get_dynamic_gas_price()

        tx_params: TxParams = {
            "nonce": nonce,
            "gasPrice": gas_price,
            "gas": 300000,  # Adjust as needed
            "to": self.contract_addr,
            "from": self.account.address,
            "data": self.contract.encodeABI(fn_name="pause"),
        }

        signed_tx = self.account.sign_transaction(tx_params)
        tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)
        return self.w3.eth.wait_for_transaction_receipt(tx_hash)

    def store_pause_event(
        self, triggering_tx_hash: str, pause_tx_hash: str, success: bool
    ):
        with psycopg2.connect(self.db_conn_string) as conn:
            with conn.cursor() as cur:
                cur.execute(
                    """
                    INSERT INTO pause_events (triggering_tx_hash, pause_tx_hash, success, timestamp)
                    VALUES (%s, %s, %s, NOW())
                """,
                    (triggering_tx_hash, pause_tx_hash, success),
                )

    def pause_contract(self, triggering_tx_hash: str):
        try:
            tx_receipt = self.send_pause_transaction()
            if tx_receipt:
                logger.info(
                    f"Contract paused. Transaction mined in block {tx_receipt['blockNumber']}"
                )
                self.store_pause_event(
                    triggering_tx_hash, tx_receipt["transactionHash"].hex(), True
                )
            else:
                logger.error("Failed to pause contract: No transaction receipt")
                self.store_pause_event(triggering_tx_hash, "", False)
        except Exception as e:
            logger.error(f"Failed to pause contract: {e}")
            self.store_pause_event(triggering_tx_hash, "", False)

    def run_vulnerability_analysis(self):
        try:
            result = subprocess.run(
                ["mythril", "-a", self.contract_addr], capture_output=True, text=True
            )
            if result.returncode != 0:
                logger.error(f"Vulnerability analysis failed: {result.stderr}")
            else:
                logger.info(f"Vulnerability analysis result: {result.stdout}")
        except Exception as e:
            logger.error(f"Error running vulnerability analysis: {e}")

    def monitor_pending_transactions(self):
        def handle_pending(transaction):
            if transaction["to"] == self.contract_addr:
                logger.info(
                    f"Pending transaction to contract detected: {transaction['hash'].hex()}"
                )
                # self.pause_contract(transaction["hash"].hex())

        pending_filter = self.w3.eth.filter("pending")
        while True:
            for tx_hash in pending_filter.get_new_entries():
                tx = self.w3.eth.get_transaction(tx_hash)
                handle_pending(tx)
            time.sleep(1)


def main():
    client_url = os.getenv("ETHEREUM_CLIENT_URL")
    contract_addr = os.getenv("CONTRACT_ADDRESS")
    owner_addr = os.getenv("OWNER_ADDRESS")
    private_key = os.getenv("PRIVATE_KEY")
    db_conn_string = os.getenv("DB_CONN_STRING")

    pauser = ContractPauser(
        client_url, contract_addr, owner_addr, private_key, db_conn_string
    )

    # Run vulnerability analysis once
    import threading

    def run_analysis():
        # while True:
        pauser.run_vulnerability_analysis()
        # time.sleep(24 * 60 * 60)  # Run daily

    analysis_thread = threading.Thread(target=run_analysis)
    analysis_thread.start()

    pauser.monitor_pending_transactions()


if __name__ == "__main__":
    main()
