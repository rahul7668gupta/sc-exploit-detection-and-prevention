import os
from flask import Flask, request, jsonify
from web3 import Web3
from eth_account import Account
from eth_tester import EthereumTester
from eth_tester.backends.pyevm import PyEVMBackend
from web3.providers.eth_tester import EthereumTesterProvider

app = Flask(__name__)

# Connect to Mainnet
INFURA_URL = os.getenv("ETHEREUM_CLIENT_URL")
w3 = Web3(Web3.HTTPProvider(INFURA_URL))

# Create a custom mainnet fork
custom_genesis_params = PyEVMBackend._generate_genesis_params(
    overrides={"gas_limit": 10000000}
)
pyevm_backend = PyEVMBackend(genesis_parameters=custom_genesis_params)
eth_tester = EthereumTester(backend=pyevm_backend)
provider = EthereumTesterProvider(eth_tester)
w3_fork = Web3(provider)


def set_fork_state(target_block):
    while w3_fork.eth.block_number < target_block:
        eth_tester.mine_blocks(1)


@app.route("/simulate-transaction", methods=["POST"])
def simulate_transaction():
    try:
        tx_hash = request.json.get("txHash")
        if not tx_hash:
            return jsonify({"error": "Transaction hash is required"}), 400

        # Get the pending transaction from the mempool
        pending_tx = w3.eth.get_transaction(tx_hash)
        if not pending_tx:
            return jsonify({"error": "Transaction not found in mempool"}), 404

        # Set the state of our forked chain to match the current mainnet state
        latest_block = w3.eth.get_block("latest")
        set_fork_state(latest_block.number)

        # Fund the sender's account in our forked chain
        eth_tester.add_account(pending_tx["from"])
        eth_tester.send_transaction(
            {
                "from": eth_tester.get_accounts()[0],
                "to": pending_tx["from"],
                "value": w3.eth.get_balance(pending_tx["from"]) + pending_tx["value"],
            }
        )

        # Simulate the transaction
        tx_params = {
            "from": pending_tx["from"],
            "to": pending_tx["to"],
            "value": pending_tx["value"],
            "gas": pending_tx["gas"],
            "gasPrice": pending_tx["gasPrice"],
            "nonce": pending_tx["nonce"],
            "data": pending_tx["input"],
        }

        # Send the transaction
        tx_hash = eth_tester.send_transaction(tx_params)

        # Wait for the transaction to be mined
        tx_receipt = w3_fork.eth.wait_for_transaction_receipt(tx_hash)

        # Return the simulation results
        return jsonify(
            {
                "success": True,
                "transactionHash": tx_receipt["transactionHash"].hex(),
                "blockNumber": tx_receipt["blockNumber"],
                "gasUsed": tx_receipt["gasUsed"],
                "logs": [log.to_dict() for log in tx_receipt["logs"]],
                "status": tx_receipt["status"],
            }
        )

    except Exception as e:
        return (
            jsonify({"error": "Error simulating transaction", "details": str(e)}),
            500,
        )


if __name__ == "__main__":
    app.run(debug=True, port=3000)
