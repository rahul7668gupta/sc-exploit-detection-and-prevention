const { ethers } = require("ethers");
require('dotenv').config();

const httpUrl = process.env.RPC_URL; // Update this to your local Anvil WebSocket URL

// Replace with your Infura or other Ethereum node WebSocket URL
const provider = new ethers.JsonRpcProvider(httpUrl);

async function isReentrancyAttack(txHash) {
  try {
    // Get the transaction details
    const tx = await provider.getTransaction(txHash);
    if (!tx) {
      console.log(`Transaction ${txHash} not found.`);
      return false;
    }

    // Get the transaction trace
    const trace = await provider.send("debug_traceTransaction", [txHash]);

    // Initialize variables to track the state
    let externalCallCount = 0;
    let lastStateUpdate = -1;

    // Iterate through the trace
    for (let i = 0; i < trace.structLogs.length; i++) {
      const step = trace.structLogs[i];

      // Check for external calls
      if (step.op === "CALL" || step.op === "DELEGATECALL") {
        externalCallCount++;
      }

      // Check for state updates
      if (step.gasCost > 0) {
        lastStateUpdate = i;
      }

      // Check for potential reentrancy
      if (externalCallCount > 1 && lastStateUpdate < i) {
        // Multiple external calls before state update, potential reentrancy attack
        return true;
      }
    }

    // No potential reentrancy attack found
    return false;
  } catch (error) {
    console.error(`Error analyzing transaction ${txHash}:`, error);
    return false;
  }
}

// Example usage
const transactionHash = "0x13e0e04768ac0cd887440086df9a63e050cc041f3c9c9f74fef9bc2afd6e6f4f";

isReentrancyAttack(transactionHash)
  .then((isAttack) => {
    console.log(`Transaction ${transactionHash} is ${isAttack ? 'a potential reentrancy attack' : 'not a reentrancy attack'}`);
  })
  .catch((error) => {
    console.error('Error:', error);
  });