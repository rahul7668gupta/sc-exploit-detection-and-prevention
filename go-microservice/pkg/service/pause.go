package service

import (
	"context"
	"log"
	"math/big"

	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
)

func (cp *ContractPauser) PauseContract(triggeringTxHash common.Hash) {
	gasPrice, err := cp.GetDynamicGasPrice()
	if err != nil {
		log.Printf("Failed to get dynamic gas price: %v", err)
		return
	}

	chainID, err := cp.client.ChainID(context.Background())
	if err != nil {
		log.Printf("Failed to get chain ID: %v", err)
		return
	}

	privateKey, err := crypto.HexToECDSA(cp.privateKey)
	if err != nil {
		log.Printf("Failed to convert private key: %v", err)
		return
	}

	auth, err := bind.NewKeyedTransactorWithChainID(privateKey, chainID)
	if err != nil {
		log.Printf("Failed to create authorized transactor: %v", err)
		return
	}

	auth.GasPrice = gasPrice
	auth.GasLimit = 300000 // Adjust as needed

	tx, err := cp.SendPauseTransaction(auth)
	if err != nil {
		log.Printf("Failed to pause contract: %v", err)
		cp.storePauseEvent(triggeringTxHash.Hex(), "", false)
		return
	}

	log.Printf("Pause transaction sent: %s", tx.Hash().Hex())

	receipt, err := bind.WaitMined(context.Background(), cp.client, tx)
	if err != nil {
		log.Printf("Failed to get transaction receipt: %v", err)
		cp.storePauseEvent(triggeringTxHash.Hex(), tx.Hash().Hex(), false)
		return
	}

	log.Printf("Contract paused. Transaction mined in block %d", receipt.BlockNumber.Uint64())
	cp.storePauseEvent(triggeringTxHash.Hex(), tx.Hash().Hex(), true)
}

func (cp *ContractPauser) SendPauseTransaction(auth *bind.TransactOpts) (*types.Transaction, error) {
	// Implement your contract pause logic here
	return types.NewTransaction(
		0,
		cp.contractAddr,
		big.NewInt(0),
		auth.GasLimit,
		auth.GasPrice,
		[]byte("pause"), // This should be the actual ABI-encoded function call
	), nil
}

func (cp *ContractPauser) GetDynamicGasPrice() (*big.Int, error) {
	suggestedGasPrice, err := cp.client.SuggestGasPrice(context.Background())
	if err != nil {
		return nil, err
	}

	premium := new(big.Int).Div(suggestedGasPrice, big.NewInt(5))
	return new(big.Int).Add(suggestedGasPrice, premium), nil
}
