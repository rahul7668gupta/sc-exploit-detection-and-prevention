package service

import (
	"context"
	"encoding/json"
	"log"
	"math/big"
	"strings"
	"sync"
	"time"

	"github.com/ethereum/go-ethereum/common"
	"github.com/rahul7668gupta/sc-exploit/pkg/dto"
	"github.com/rahul7668gupta/sc-exploit/pkg/model"
)

type TxPoolContent struct {
	Pending map[string]map[string]TxPoolTransaction `json:"pending"`
}

type TxPoolTransaction struct {
	BlockHash        string `json:"blockHash"`
	BlockNumber      string `json:"blockNumber"`
	From             string `json:"from"`
	Gas              string `json:"gas"`
	GasPrice         string `json:"gasPrice"`
	Hash             string `json:"hash"`
	Input            string `json:"input"`
	Nonce            string `json:"nonce"`
	To               string `json:"to"`
	TransactionIndex string `json:"transactionIndex"`
	Value            string `json:"value"`
}

type TransactionDetails struct {
	Hash        common.Hash     `json:"hash"`
	From        common.Address  `json:"from"`
	To          *common.Address `json:"to"`
	Input       string          `json:"input"`
	Value       *big.Int        `json:"value"`
	GasLimit    uint64          `json:"gas"`
	GasPrice    *big.Int        `json:"gasPrice"`
	Nonce       uint64          `json:"nonce"`
	BlockHash   *common.Hash    `json:"blockHash"`
	BlockNumber *big.Int        `json:"blockNumber"`
}

type FeeHistoryResponse struct {
	BaseFeePerGas []string `json:"baseFeePerGas"`
}

func (cp *ContractPauser) GetBaseFee() (*big.Int, error) {
	var feeHistory FeeHistoryResponse
	err := cp.client.Client().CallContext(context.Background(), &feeHistory, "eth_feeHistory", 1, "latest", []float64{})
	if err != nil {
		return nil, err
	}

	if len(feeHistory.BaseFeePerGas) > 0 {
		baseFee, _ := new(big.Int).SetString(feeHistory.BaseFeePerGas[0][2:], 16)
		return baseFee, nil
	}

	return big.NewInt(0), nil
}

func (cp *ContractPauser) MonitorPendingTransactions() {
	log.Printf("Monitoring pending transactions for address %s", cp.contractAddrAttack.Hex())
	var wg sync.WaitGroup

	wg.Add(1)
	// process pending transactions with details
	go func() {
		defer wg.Done()
		var metrics model.PerformanceMetrics
		metricsTicker := time.NewTicker(5 * time.Second)
		defer metricsTicker.Stop()

		for {
			select {
			case pendingTxn := <-cp.pendingTxnDetails:
				if pendingTxn.To != nil && !strings.EqualFold(pendingTxn.To.Hex(), cp.contractAddrAttack.Hex()) {
					continue
				}
				cp.ProcessPendingTransactionWithDetail(pendingTxn, &metrics)
			case <-metricsTicker.C:
				cp.storePerformanceMetrics(metrics)
				metrics = model.PerformanceMetrics{
					ProcessedTxCount: 0,
				}
			}
		}
	}()

	wg.Add(1)
	// process pending transactions
	go func() {
		defer wg.Done()
		for result := range cp.pendingTxs {
			for _, txs := range result.Pending {
				for _, tx := range txs {
					gas, _ := new(big.Int).SetString(tx.Gas[2:], 16)
					gasPrice, _ := new(big.Int).SetString(tx.GasPrice[2:], 16)
					value, _ := new(big.Int).SetString(tx.Value[2:], 16)
					nonce, _ := new(big.Int).SetString(tx.Nonce[2:], 16)

					var to *common.Address
					if tx.To != "" {
						toAddr := common.HexToAddress(tx.To)
						to = &toAddr
					}

					// unrelated transactions
					if to == nil {
						continue
					} else if to.Hex() != cp.contractAddrAttack.Hex() {
						continue
					}

					txDetails := TransactionDetails{
						Hash:     common.HexToHash(tx.Hash),
						From:     common.HexToAddress(tx.From),
						To:       to,
						Input:    tx.Input,
						Value:    value,
						GasLimit: gas.Uint64(),
						GasPrice: gasPrice,
						Nonce:    nonce.Uint64(),
					}
					// send txn to the channel
					cp.pendingTxnDetails <- txDetails
				}
			}
		}
	}()

	wg.Add(1)
	// monitor pending txns from pool
	go func() {
		defer wg.Done()
		for {
			var result TxPoolContent
			err := cp.client.Client().CallContext(context.Background(), &result, "txpool_content")
			if err != nil {
				log.Fatalf("Failed to get pending transactions: %v", err)
			}
			cp.pendingTxs <- result
			time.Sleep(1 * time.Second) // this can be adjusted based on the frequency of transactions and block time
		}
	}()

	wg.Add(1)
	// send email notifications
	go func() {
		defer wg.Done()
		var reentrancyTxMap = make(map[string]bool)
		for emailContent := range cp.emailNotification {
			if reentrancyTxMap[emailContent.PauseContractAddress] {
				log.Printf("Email already sent for %s", emailContent.PauseContractAddress)
				continue
			}
			log.Printf("Sending email for %s", emailContent.PauseContractAddress)
			err := cp.emailService.SendEmail(emailContent.PauseContractAddress, emailContent.ReentrancyHash, emailContent.PauseHash)
			if err != nil {
				log.Printf("Failed to send email: %+v", err)
				continue
			}
			reentrancyTxMap[emailContent.PauseContractAddress] = true
			log.Printf("Email sent for %s", emailContent.PauseContractAddress)
		}
	}()

	wg.Wait()
}

func (cp *ContractPauser) IsSuspiciousTransaction(result map[string]interface{}) (bool, error) {
	// Implement your suspicious transaction detection logic here

	var dtoResp dto.TenderlySimulateResponse

	resultBytes, err := json.Marshal(result)
	if err != nil {
		log.Printf("Failed to marshal result: %v", err)
		return false, err
	}

	err = json.Unmarshal(resultBytes, &dtoResp)
	if err != nil {
		log.Printf("Failed to unmarshal result: %v", err)
		return false, err
	}

	return cp.DetectReentrancy(dtoResp)
}

func (cp *ContractPauser) DetectReentrancy(result dto.TenderlySimulateResponse) (bool, error) {
	reentrancyScore := 0

	// Check for nested calls
	if len(result.Result.Trace) < 2 {
		return false, nil
	}

	// Check for repeated interactions
	interactionCount := make(map[string]int)
	for _, trace := range result.Result.Trace {
		key := trace.From + "-" + trace.To
		interactionCount[key]++
		if interactionCount[key] > 1 {
			log.Printf("Repeated interaction detected: %s", key)
			reentrancyScore += interactionCount[key]
		}
	}

	// Check for multiple ETH transfers of the same amount from and to the same addresses
	transferCount := make(map[string]int)
	for _, change := range result.Result.AssetChanges {
		if change.Type == "Transfer" {
			key := change.From + "-" + change.To + "-" + change.Amount
			transferCount[key]++
			if transferCount[key] > 1 {
				log.Printf("Repeated transfer detected: %s", key)
				reentrancyScore += transferCount[key]
			}
		}
	}

	// Check for similar function calls
	functionCalls := make(map[string]int)
	for _, trace := range result.Result.Trace {
		if len(trace.Input) >= 10 {
			functionSignature := trace.Input[:10]
			id := trace.From + "-" + trace.To + "-" + functionSignature
			functionCalls[id]++
			if functionCalls[id] > 1 {
				log.Printf("Repeated function call detected: %s", id)
				reentrancyScore += functionCalls[id]
			}
		}
	}

	// check if a trace has CALL or DELEGATECALL to cp.contractAddrVulnerableProxy
	for _, trace := range result.Result.Trace {
		if strings.EqualFold(trace.To, cp.contractAddrVulnerableProxy.Hex()) {
			log.Printf("Contract %s called by %s", cp.contractAddrVulnerableProxy.Hex(), trace.From)
			reentrancyScore++
		}
	}

	log.Printf("Reentrancy score: %d", reentrancyScore)

	if reentrancyScore > 1 { // adjust this threshold based on the contract's behavior
		return true, nil
	}

	return false, nil
}
